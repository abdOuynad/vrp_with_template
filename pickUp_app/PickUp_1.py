# -*- coding: utf-8 -*-
"""Untitled44.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cbS_N6mFcKC7q4UBX6tRZK3Cqd8aPY9A
"""

import pandas as pd
import numpy as np
from geopy.distance import geodesic


#
class vrp_by_geopy:
    #
    def __init__(self, clients, cars, coordonne, init,
                 df=None,vrp_affec_sol=None,vrp_info=[],
                 vec_dipo=[],basket={}):
        self.clients = clients
        self.cars = cars
        self.coordonne = coordonne
        self.init = init
        self.df = df
        self.vrp_affec_sol=vrp_affec_sol
        self.vrp_info=vrp_info
        self.vec_dipo=vec_dipo
        self.basket=basket

    #
    @property
    def clients(self):
        return self.clients
    #
    @clients.setter
    def clients(self,val):
        self._clients=val
    #
    @property
    def cars(self):
        return self.cars
    #
    @cars.setter
    def cars(self,val):
        self._cars=val
    #
    @property
    def coordonne(self):
        return self.coordonne
    #
    @coordonne.setter
    def coordonne(self,val):
        self._coordonne=val
    #
    @property
    def init(self):
        return self.init
    #
    @init.setter
    def init(self,val):
        self._init=val
    #
    @property
    def df(self):
        return self.df
    #
    @df.setter
    def df(self, val):
        self._df = val
    #
    @property
    def vrp_affec_sol (self):
        return self.vrp_affec_sol
    #
    @vrp_affec_sol.setter
    def vrp_affec_sol(self, val):
        self._vrp_affec_sol = val
    #
    @property
    def vrp_info(self):
        return self.vrp_info
    #
    @vrp_info.setter
    def vrp_info(self, val):
        self._vrp_info = val
    #
    @property
    def vec_dipo(self):
        return self.vec_dipo

    #
    @vec_dipo.setter
    def vec_dipo(self, val):
        self._vec_dipo = val
    #
    @property
    def basket(self):
        return self.basket
    #
    @basket.setter
    def basket(self, val):
        self._basket = val
    #
    def add_client(self, client):
        self._clients.append(client)
    #
    def add_coordonne(self, cord):
        self._coordonne.append(cord)
    #
    def drop_client_to_df(self,client):
        self._df=self._df.drop(index=client,columns=client)
    #
    def remove_client_to_clients(self,client):
        self._clients.remove(client)
    #
    def add_client_to_df_dist_sorted(self, client, cord):
        #
        new_client_column = list((map(lambda x: float(str(geodesic(cord, x)).strip('km')), self._coordonne)))
        #
        self.add_client(client)
        self.add_coordonne(cord)
        #
        # new_client_dict = list(zip(list(map(lambda x: float(str(geodesic(x, cord)).strip('km')),self.coordonne)),self.clients))
        #
        new_client_rows = list(map(lambda x: float(str(geodesic(x, cord)).strip('km')),
                                   self._coordonne))

        #
        self._df[client] = new_client_column
        self._df.loc[client] = new_client_rows
        #
        new_client = list(zip(self._df.loc[client], list(self._df.columns)))
        #
        # print("size ===> ",len(new_client)," vs ",len(new_client_dict))
        # print(new_client,"\n",new_client_dict)
        # [(2993.3655245385476, 'C0001'), (2997.1401643694276, 'C0003'),
        new_client = sorted(new_client)
        #
        return new_client

    #
    def add_clien_to_vrp(self,client, avnc, cord):
        #
        m = []
        #
        dict_dis = self.add_client_to_df_dist_sorted(client, cord)
        #
        for i, x in enumerate(self._vrp_affec_sol):
            #
            k=avnc[i]
            if isinstance(k,dict):
                k = list(avnc[i].values())[0]
            #
            init = list(x.values())[0][k]
            list_client = list(x.values())[0][k:]
            new_dict_dis = [x for x in dict_dis if x[1] in list_client]
            l = sorted(new_dict_dis)[0]
            #
            m.append((l[0], l[1], list(x.keys())[0], i, k))
            #
        index = min(m)
        clients = list(self._vrp_affec_sol[index[3]].values())[0]
        sorted_list = self.ajout(clients, client, index[4])
        #
        self._vrp_affec_sol[index[3]][index[2]] = sorted_list
        #
        return self._vrp_affec_sol

    #
    def add_clien_to_vrp_dict(self,client, cord, pos):
        #
        pos_index =0
        m = []
        #
        dict_dis = self.add_client_to_df_dist_sorted(client, cord)
        #
        for x,y in self._vrp_affec_sol.items():
            #
            #
            y['pos'] = pos[pos_index]
            k =y['pos']
            #
            init = y['sol'][k]
            list_client = y['sol'][k:]
            new_dict_dis = [x for x in dict_dis if x[1] in list_client]
            l = sorted(new_dict_dis)[0]
            #
            m.append((l[0], l[1], x, k))
            #
            pos_index+=1
            #
        index = min(m)
        clients = self._vrp_affec_sol[index[2]]['sol']
        sorted_list = self.ajout(clients, client, index[3])
        #
        self._vrp_affec_sol[index[2]]['sol'] = sorted_list
        #
        return self._vrp_affec_sol

    #
    def add_clien_to_vrp_dict_new(self,pos,client, cord):
        #
        m = []
        #
        dict_dis = self.add_client_to_df_dist_sorted(client, cord)
        #
        self._vrp_affec_sol = sol
        #
        for x,y in self._vrp_affec_sol.items():
            #
            k=y['pos']
            #
            init = y['sol'][k]
            list_client = y['sol'][k:]
            new_dict_dis = [x for x in dict_dis if x[1] in list_client]
            l = sorted(new_dict_dis)[0]
            #
            m.append((l[0], l[1], x, k))
            #
        index = min(m)
        clients = self._vrp_affec_sol[index[2]]['sol']
        sorted_list = self.ajout(clients, client, k)
        #
        self._vrp_affec_sol[index[2]]['sol'] = sorted_list
        #
        return self._vrp_affec_sol

    #
    #
    def create_distance_matrix(self):
        matrix = []
        for cor in self._coordonne:
            distance = list(map(lambda x: float(str(geodesic(cor, x)).strip('km')),
                                self._coordonne))
            matrix.append(distance)
        #
        return matrix

    #
    def vector_init_distance(self):
        init_dis = list(
            zip(list(map(lambda x: float(str(geodesic(self._init, x)).strip('km')),
                         self._coordonne)), self._clients))
        #
        self._vec_dipo=init_dis
        #
        return init_dis

    #
    def matrix_to_df(self, matrix):
        df = pd.DataFrame(data=matrix, columns=self._clients, index=self._clients)
        #
        self.df = df
        #
        return df

    #
    def affec(self, dict_client_distnace, init, list_client):
        result = []
        dict_position_trie_by_client = {}
        for k, v in dict_client_distnace.items():
            list_position_trie = sorted(v)
            dict_position_trie_by_client[k] = [x for x in list_position_trie if x[1] in list_client]
        #
        #
        for i in list_client:
            result.append(init)
            index = 1
            for x in list_client[:-2]:
                if dict_position_trie_by_client[init][index][1] in result:
                    index += 1
                else:
                    init = dict_position_trie_by_client[init][index][1]
                    break
        return result

    #
    def affec_new(self, dict_client_distnace, init, list_client):
        result = []
        dict_position_trie_by_client = {}
        for k, v in dict_client_distnace.items():
            #print('key ==>',k)
            list_position_trie = sorted(v)
            dict_position_trie_by_client[k] = [x for x in list_position_trie if x[1] in list_client]
        #
        #
        for i in list_client:
            result.append(init)
            index = 1
            for x in list_client[:-2]:
                if dict_position_trie_by_client[init][index][1] in result:
                    index += 1
                else:
                    init = dict_position_trie_by_client[init][index][1]
                    break
        return result
    #
    def affec_rcv(self, init, list_client, dict_client_distance, result=[]):
        if len(list_client) == 1:
            result.append(list_client[-1])
            return result
        else:
            list_dist = dict_client_distance[init]
            list_dist = sorted(list_dist)
            list_dist = [x for x in list_dist if x[1] in list_client]
            next = list_dist[0][1]
            list_client.remove(next)
            result.append(next)
            return self.affec_rcv(next, list_client, dict_client_distance, result)

    #
    #
    def ajout(self, clients, client, k):
        result = clients[:k]
        new_list_client = clients[k:]
        new_list_client.append(client)
        #
        d = {}
        #
        for c in new_list_client:
            # print(data[c].index)
            d[c] = list(zip(list(self._df[c]), list(self._df[c].index)))
        # d[client] = list(zip(list(self.df[client]), list(self.df[client].index)))
        #
        #trie = self.affec_new(d, new_list_client[0], new_list_client)
        trie = self.affec_rcv(new_list_client[0], new_list_client, d,result=[])
        #
        return (result + trie)

    #
    def vrp_init(self, dipo_ds, matrix):
        sol = {}
        result = []
        rslt = []
        dipo = [x for x in dipo_ds if x[1] in self._clients]
        dipo = sorted(dipo)
        # print('dipo \n',dipo)
        self.init_basket()
        #
        sol[self._cars[0]] = dipo[0]
        result.append(sol)
        rslt.append({self._cars[0]: [dipo[0][1]]})
        # print("result ==>",result)
        for v in self._cars[1:]:
            # print('v ===>',v)
            sol = {}
            chemin = [list(x.values())[0][1] for x in result]
            # print('chemin ==>',chemin)
            rest = [x for x in self._clients if x not in chemin]
            #
            dis = {}
            for r in rest:
                s = 0
                for n in chemin:
                    a = matrix.loc[r][n]
                    b = matrix.loc[n][r]
                    if a > b:
                        s += a
                    else:
                        s += b
                dis[s] = r
            dis = sorted(dis.items(), key=lambda item: item[1])
            # print('dis ===>', dis)
            max = dis[-1]
            #
            # print('max===>',max[1])
            sol[v] = max
            #
            result.append(sol)
            rslt.append({v: [max[1]]})

        # return result
        return rslt

    #
    def annulation_other(self, client, k, clients, data):
        if k==0:
            result=[]
        else:
            result = clients[:k]
        list_client = clients[k:]
        list_client.remove(client)
        #
        d = {}
        # p = []
        # print(list_client)
        for c in list_client:
            # print(data[c].index)
            d[c] = list(zip(list(data[c]), list(data[c].index)))
        #
        trie = self.affec(d, list_client[0], list_client)
        return result + trie
    #
    def annulation(self, client,clients,k=0):

        result = clients[:k]
        list_client = clients[k:]
        list_client.remove(client)
        #
        #
        d = {}
        # p = []
        # print(list_client)
        for c in list_client:
            # print(data[c].index)
            d[c] = list(zip(list(self._df[c]), list(self._df[c].index)))
        #
        #print(d)
        #
        trie = self.affec_rcv(list_client[0], list_client,d ,result=[])
        return result + trie
    #
    def init_basket(self):
        for x in self._cars:
            self._basket[x]=[]
    #
    def find_and_annulation(self,client, k=0):
        for x in self.vrp_affec_sol:
            if client in list(x.values())[0]:
                self.basket.append({list(x.keys())[0]:client})
                list_client = list(x.values())[0]
                new_list_affec = self.annulation(client, k, list_client)
                x[list(x.keys())[0]] = new_list_affec
                return self.vrp_affec_sol
        return "the client :" + client + " not find"
    #
    def find_and_annulation_dict(self,client,pos):
        #
        index = 0
        #
        for x,y in self._vrp_affec_sol.items():
            if client in y['sol']:
                self._basket[x].append(client)
                y['pos'] = int(pos[index])
                list_client = y['sol']
                new_list_affec = self.annulation(client, list_client,y['pos'])
                y['sol'] = new_list_affec
                self.drop_client_to_df(client)
                index+=1
                return self._vrp_affec_sol
        return "the client :" + client + " not find"
    #
    def convert(self, data):
        d = {}
        for c in self._clients:
            d[c] = list(zip(list(data[c]), list(data[c].index)))
        return d

    #
    def compare(self, init_vrp, all_tourne):
        basket = []
        rslt = []
        for index in range(len(all_tourne[0])):
            # print(index)
            for line in list(zip(all_tourne, self.cars)):
                # print(line[0][index])
                if line[0][index] not in basket:
                    rslt.append((line[1], line[0][index]))
                    basket.append(line[0][index])
        return rslt

    #
    def affect(slef, init, list_clients_rest, dict_client):
        # print('affect ===>',dict_client,'list rest ===>',list_clients_rest)
        new_dict = [x for x in dict_client[init] if x[1] in list_clients_rest]
        return new_dict

    #
    def min_dis(self, list_dis_client):
        list_dis_client = sorted(list_dis_client)
        return list_dis_client[0][1]

    #
    def list_client_rest(self, init_dict):
        full = []
        # main
        for x in init_dict:
            init = list(x.values())[0][-1]
            #
            if init not in full:
                full.append(init)
            #
        return [x for x in self._clients if x not in full]

    #
    def affectation_client(self, init_vrp, dict_client):
        #
        init_vrp_copy = init_vrp
        rest = self.list_client_rest(init_vrp_copy)
        #
        while (len(rest) != 0):

            for x in init_vrp_copy:
                init = list(x.values())[0][-1]
                aff = self.affect(init, rest, dict_client)
                nrml = self.min_dis(aff)
                v = list(x.keys())[0]
                x[v].append(nrml)
                rest.remove(nrml)
                if len(rest) == 0:
                    break
        # print("result ==>", init_vrp_copy)
        self.vrp_sol_to_dict(init_vrp_copy)

    #
    def vrp_affec_rcv(self, cars, dict_dist, list_client, car_index=0, list_affec=[]):
        if len(list_client) == 1:
            # list(cars[car_index].values())[0].append(list_client[-1])
            return cars
        #
        if len(list_affec) == 0:
            for c in cars:
                list_affec.append(list(c.values())[0][0])
                # print(list(c.values())[0][0])
        #
        if len(list_client) != 1:
            init = list(cars[car_index].values())[0][-1]
            # print('init ==>',init)
            list_client = [x for x in list_client if x not in list_affec]
            # print('list client ==>',list_client)
            #
            list_dis = [x for x in dict_dist[init] if x[1] in list_client]
            list_dis = sorted(list_dis)
            next = list_dis[0][1]
            list_affec.append(next)
            list(cars[car_index].values())[0].append(next)
            #
            if car_index == len(cars) - 1:
                car_index = 0
            else:
                car_index += 1
            #
            # print('cars ==>',cars)
            # print('list_dis ==>',list_dis)
            # print('next ==>',next)
            #
            return self.vrp_affec_rcv(cars, dict_dist, list_client, car_index, list_affec)

    #
    def vrp_sol_to_dict(self,vrp_sol):
        d={}
        for x in vrp_sol:
            s={}
            #
            s['sol']=list(x.values())[0]
            #
            s['pos']=0
            #
            d[list(x.keys())[0]]=s
        #
        self._vrp_affec_sol=d
    #
    def possible(self, df, init_tourn):
        all_affec = []  # this list for recive all affect posible
        df_to_dict = self.convert(df)
        for x, c in enumerate(init_tourn):
            init = list(init_tourn[x].values())[0]
            all_affec.append(self.affec(df_to_dict, init))
        return all_affec

    #
    def affected(self, optmz_list):
        aff = []
        for v in self.cars:
            d = {}
            d[v] = [y for x, y in optmz_list if x == v]
            aff.append(d)
        return (aff)

    #
    def all_distance(self, init_vec, x, data):
        s = [i[0] for i in init_vec if i[1] == list(x.values())[0][0]]
        # print(x)
        for y, z in enumerate(list(x.values())[0][1:-1]):
            # print(list(x.values())[0][y])
            a = list(x.values())[0][y]
            # print(list(x.values())[0][y+1])
            b = list(x.values())[0][y + 1]
            s += data.loc[a][b]
            # print('==================================')
        return s[0]
    #
    def all_distance_dict(self, init_vec, x, data):
        s = [i[0] for i in init_vec if i[1] == x[0]]
        # print(x)
        for y, z in enumerate(x[1:-1]):
            # print(list(x.values())[0][y])
            a = x[y]
            # print(list(x.values())[0][y+1])
            b = x[y + 1]
            s += data.loc[a][b]
            # print('==================================')
        return s[0]
    #
    def max_distance(self, init_vec, x, data):
        list_dist = []
        init = [i[0] for i in init_vec if i[1] == list(x.values())[0][0]]
        s = (init[0],
             'dipo',
             list(x.values())[0][0])
        # print(x)
        list_dist.append(s)
        for y, z in enumerate(list(x.values())[0][1:-1]):
            # print(list(x.values())[0][y])
            a = list(x.values())[0][y]
            # print(list(x.values())[0][y+1])
            b = list(x.values())[0][y + 1]
            s = (data.loc[a][b], a, b)
            list_dist.append(s)
            # print('==================================')
        return sorted(list_dist)[-1]
    #
    def max_distance_vec(self, init_vec, x, data):
        list_dist = []
        init = [i[0] for i in init_vec if i[1] == x[0]]
        s = (init[0],
             'dipo',
             x[0] )
        # print(x)
        list_dist.append(s)
        for y, z in enumerate(x[1:-1]):
            # print(list(x.values())[0][y])
            a = x[y]
            # print(list(x.values())[0][y+1])
            b = x[y + 1]
            s = (data.loc[a][b], a, b)
            list_dist.append(s)
            #print('==================================')
        return list(sorted(list_dist))[-1]
    #
    def vrp_sol_info(self,vec_dis, data):
        info = []
        for x in self._vrp_affec_sol.items():
            d = {}
            d['name'] = list(x.keys())[0]
            d['size'] = len(list(x.values())[0])
            d['full_Distance'] = self.all_distance(vec_dis, x, data)
            d['max_Distance'] = self.max_distance(vec_dis, x, data)
            if(list(x.keys())[0] in [list(y.keys())[0] for y in self._basket]):
                d['delet']=[list(y.values())[0] for y in self._basket if list(y.keys())[0] == list(x.keys())[0]]
            #
            info.append(d)
        #
        self._vrp_info=info
        #
        return info

    #
    def vrp_sol_info_dict(self):
        info = {}
        for x,y in self._vrp_affec_sol.items():
            d = {}
            d['size'] = len(y['sol'])
            d['full_Distance'] = self.all_distance_dict(self._vec_dipo, y['sol'], self._df)
            d['max_Distance'] = self.max_distance_vec(self._vec_dipo, y['sol'], self._df)
            if(x in [y for y in self._basket]):
                d['delet']=self._basket[x]
            #
            info[x]=d
        #
        self._vrp_info=info
        #
        return info

    #
    def next_step(self,vrp_name):
        #
        index=self._vrp_affec_sol[vrp_name]['pos']
        #
        self._vrp_affec_sol[vrp_name]['pos']+=1
        #
        client=self._vrp_affec_sol[vrp_name]['sol'][index]
        #
        self.drop_client_to_df(client)
    #
    def all_avnc(self,avnc):
        if len(avnc)!= len(self._vrp_affec_sol):
            return 'Errore shape'
        avnc=iter(avnc)
        for x,y in self._vrp_affec_sol.items():
            p=next(avnc)
            [self.drop_client_to_df(y['sol'][x]) for x in range(int(p)-1) if y['sol'][x] in self._df.columns]
            y['pos']=p

    #
    def __repr__(self):
        return f" the clients ==>{self._clients}\n" \
               f" the cars ==> {self._cars}\n" \
               f" the vrp sol ==> {self._vrp_affec_sol}" \
               f" the vrp sol info ==> {self._vrp_info} "
    #


#
if __name__ == '__main__':
    #
    # creat data for test the model vrp_by_geopy
    #
    data = pd.read_excel('testdata.xls')
    data = data[:20]
    list_client = list(data['Client '])
    crdn = list(zip(list(data['latitude']), list(data['longitude'])))
    #
    depo = (36.7149768, 3.2094611)
    cars = ['v1', 'v2', 'v3', 'v4']
    #
    # creat new vrp_by_geopy_class
    #
    tour = vrp_by_geopy(list_client, cars, crdn, depo)
    #
    # creat matrix of the distance by geopy
    #
    matrix = tour.create_distance_matrix()
    #
    print(matrix)
    # convert the matrix to dataframe
    #
    df = tour.matrix_to_df(matrix)
    #
    # create dict client and all distance between other clients
    #
    dict_client_dict = tour.convert(df)
    #
    # create vector of the distance between depo and client
    #
    vec_dis_depo = tour.vector_init_distance()
    #
    # create dict of any car with init client
    #
    init_vrp = tour.vrp_init(vec_dis_depo, df)
    print('intialisation ==>',init_vrp)
    #
    # affectation the rest clients use the vrp methode
    #
    #l = list_client
    #tour.vrp_affec_sol = tour.vrp_affec_rcv(init_vrp, dict_client_dict, l)
    tour.affectation_client(init_vrp,dict_client_dict)
    #
    print(tour._vrp_affec_sol)
    #print(tour.vrp_affec_sol)
    #print(tour.vrp_sol_info(vec_dis_depo, df), '\n')
    #
    #print(tour.find_and_annulation('C0105', df, 0),'\n')
    #print(tour.vrp_sol_info(vec_dis_depo, df),'\n')
    #
    #avc = [{'k': 2}, {'k': 8}, {'k': 3}, {'k': 5}]
    sol = {'v1': {'sol': ['C0045', 'C0114', 'C0069', 'C0032', 'C0090', 'C0031', 'C0078', 'C0021', 'C0010', 'C0082', 'C0129', 'C0101', 'C0096', 'C0106', 'C0041', 'C0111', 'C0006', 'C0036', 'C0019', 'C0009', 'C0120', 'C0029', 'C0103', 'C0100', 'C0089'], 'pos': 4}, 'v2': {'sol': ['C0139', 'C0085', 'C0044', 'C0027', 'C0012', 'C0081', 'C0005', 'C0022', 'C0020', 'C0086', 'C0124', 'C0042', 'C0084', 'C0068', 'C0076', 'C0013', 'C0127', 'C0126', 'C0048', 'C0001', 'C0053', 'C0119', 'C0098', 'C0121'], 'pos': 12}, 'v3': {'sol': ['C0138', 'C0040', 'C0102', 'C0065', 'C0071', 'C0014', 'C0025', 'C0049', 'C0134', 'C0052', 'C0131', 'C0093', 'C0080', 'C0026', 'C0016', 'C0083', 'C0057', 'C0008', 'C0073', 'C0004', 'C0113', 'C0038', 'C0003', 'C0061'], 'pos': 9}, 'v4': {'sol': ['C0136', 'C0039', 'C0023', 'C0117', 'C0054', 'C0033', 'C0079', 'C0062', 'C0046', 'C0110', 'C0015', 'C0099', 'C0047', 'C0028', 'C0018', 'C0094', 'C0070', 'C0105', 'C0115', 'C0030', 'C0024', 'C0017', 'C0035', 'C0087'], 'pos': 5}}
    #a=tour.vrp_sol_to_dict()
    #print(tour.add_clien_to_vrp('abdouy', avc, (12, 15)),'\n')
    print('ajoute ==>',tour.add_clien_to_vrp_dict('abdouy',(12, 15),[2,2,1,2]), '\n')
    print('ajoute ==>',tour.add_clien_to_vrp_dict('abdouyyy', (12.05, 15.05), [2, 3, 2, 3]), '\n')
    print('supprimer ===>',tour.find_and_annulation_dict('abdouy', [2, 3, 2, 3]), '\n')
    print('supprimer ===>', tour.find_and_annulation_dict('abdouyyy', [2, 3, 2, 3]), '\n')
    #print(tour.add_clien_to_vrp_dict('abdouyy',(12.08, 15.28),[3, 3, 2, 3]), '\n')
    #print(tour.vrp_sol_info(vec_dis_depo, df))
    print('next')
    #print(tour.find_and_annulation_dict('abdouyy',[7,8,5,7]), '\n')
    #
    #print(tour.add_clien_to_vrp_dict_1(sol,'abdouy',(12, 15)), '\n')
    #print(tour._basket)
    #print(tour.vrp_sol_info_dict())
    #print(tour._basket)
    #
    #tour.all_avnc([4,12,9,5])
    #
    #print(tour._vrp_affec_sol)
    #
    #print(tour._df)
    #
    #print(tour.find_and_annulation_dict('C0089'), '\n')
    #
    #tour.next_step('v1')
    #
    #print(tour._vrp_affec_sol)